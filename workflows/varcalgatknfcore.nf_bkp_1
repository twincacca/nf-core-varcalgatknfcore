/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IMPORT MODULES / SUBWORKFLOWS / FUNCTIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

include { FASTP } from '../modules/nf-core/fastp/main'
include { FASTQC                 } from '../modules/nf-core/fastqc/main'
include { MULTIQC                } from '../modules/nf-core/multiqc/main'
include { paramsSummaryMap       } from 'plugin/nf-validation'
include { paramsSummaryMultiqc   } from '../subworkflows/nf-core/utils_nfcore_pipeline'
include { softwareVersionsToYAML } from '../subworkflows/nf-core/utils_nfcore_pipeline'
include { methodsDescriptionText } from '../subworkflows/local/utils_nfcore_varcalgatknfcore_pipeline'
include { BWA_INDEX } from '../modules/nf-core/bwa/index/main'
include { BWA_MEM } from '../modules/nf-core/bwa/mem/main'
include { PICARD_ADDORREPLACEREADGROUPS } from '../modules/nf-core/picard/addorreplacereadgroups/main'
include { PICARD_SORTSAM } from '../modules/nf-core/picard/sortsam/main'
include { PICARD_MARKDUPLICATES } from '../modules/nf-core/picard/markduplicates/main'
include { GATK4_BASERECALIBRATOR } from '../modules/nf-core/gatk4/baserecalibrator/main'
include { SAMTOOLS_INDEX } from '../modules/nf-core/samtools/index/main'
include { SAMTOOLS_DICT } from '../modules/nf-core/samtools/dict/main'
include { SAMTOOLS_FAIDX } from '../modules/nf-core/samtools/faidx/main'
include { GATK4_APPLYBQSR } from '../modules/nf-core/gatk4/applybqsr/main'
include { GATK4_MUTECT2 } from '../modules/nf-core/gatk4/mutect2/main'
include { GATK4_FILTERMUTECTCALLS } from '../modules/nf-core/gatk4/filtermutectcalls'

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    RUN MAIN WORKFLOW
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

workflow VARCALGATKNFCORE {

    take:
    ch_samplesheet // channel: samplesheet read in from --input

    main:

    ch_versions = Channel.empty()
    ch_multiqc_files = Channel.empty()



    //
    // MODULE: FASTP
    //
    // Create a new channel (ch_adapters) using a ternary expression to use either a supplied fasta file or [].
    ch_adapters = params.adapters ? params.adapters : []

    FASTP (
        ch_samplesheet,
        ch_adapters,
        params.discard_trimmed_pass,  // <--------- need to add this one also! outdated tutorial
        params.save_trimmed_fail,
        params.save_merged
    )
    ch_multiqc_files = ch_multiqc_files.mix(FASTP.out.json.collect{it[1]}.ifEmpty([]))
    ch_versions      = ch_versions.mix(FASTP.out.versions.first())


    //
    // MODULE: Run FastQC
    //
    FASTQC (
        ch_samplesheet
    )
    ch_multiqc_files = ch_multiqc_files.mix(FASTQC.out.zip.collect{it[1]})
    ch_versions = ch_versions.mix(FASTQC.out.versions.first())

    //
    // Collate and save software versions
    //
    softwareVersionsToYAML(ch_versions)
        .collectFile(
            storeDir: "${params.outdir}/pipeline_info",
            name: 'nf_core_pipeline_software_mqc_versions.yml',
            sort: true,
            newLine: true
        ).set { ch_collated_versions }

    //
    // MODULE: MultiQC
    //
    ch_multiqc_config        = Channel.fromPath(
        "$projectDir/assets/multiqc_config.yml", checkIfExists: true)
    ch_multiqc_custom_config = params.multiqc_config ?
        Channel.fromPath(params.multiqc_config, checkIfExists: true) :
        Channel.empty()
    ch_multiqc_logo          = params.multiqc_logo ?
        Channel.fromPath(params.multiqc_logo, checkIfExists: true) :
        Channel.empty()

    summary_params      = paramsSummaryMap(
        workflow, parameters_schema: "nextflow_schema.json")
    ch_workflow_summary = Channel.value(paramsSummaryMultiqc(summary_params))

    ch_multiqc_custom_methods_description = params.multiqc_methods_description ?
        file(params.multiqc_methods_description, checkIfExists: true) :
        file("$projectDir/assets/methods_description_template.yml", checkIfExists: true)
    ch_methods_description                = Channel.value(
        methodsDescriptionText(ch_multiqc_custom_methods_description))

    ch_multiqc_files = ch_multiqc_files.mix(
        ch_workflow_summary.collectFile(name: 'workflow_summary_mqc.yaml'))
    ch_multiqc_files = ch_multiqc_files.mix(ch_collated_versions)
    ch_multiqc_files = ch_multiqc_files.mix(
        ch_methods_description.collectFile(
            name: 'methods_description_mqc.yaml',
            sort: true
        )
    )

    MULTIQC (
        ch_multiqc_files.collect(),
        ch_multiqc_config.toList(),
        ch_multiqc_custom_config.toList(),
        ch_multiqc_logo.toList()
    )


    ch_genome_fasta = Channel.fromPath(params.fasta).map { it -> [[id:it[0].simpleName], it] }.collect()
    //
    // MODULE: BWA_INDEX
    //
    BWA_INDEX (
        ch_genome_fasta // tuple val(meta), path(fasta)
    )

    //
    // MODULE: BWA_MEM
    //
    BWA_MEM (
    ch_samplesheet, //tuple val(meta) , path(reads)
    BWA_INDEX.out.index, //tuple val(meta2), path(index)
    ch_genome_fasta, //tuple val(meta3), path(fasta)
    params.sort_bam
    )

    // //
    // // MODULE: PICARD_ADDORREPLACEREADGROUPS
    // //
    PICARD_ADDORREPLACEREADGROUPS (
    BWA_MEM.out.bam, // tuple val(meta), path(reads)
    ch_genome_fasta, // tuple val(meta2), path(fasta)
    BWA_INDEX.out.index // tuple val(meta3), path(fasta_index)
    )

    // //
    // // MODULE: PICARD_SORTSAM
    // //
    PICARD_SORTSAM (
    PICARD_ADDORREPLACEREADGROUPS.out.bam, // tuple val(meta), path(bam)
    params.sort_order // val sort_order
    )

    // //
    // // MODULE: PICARD_MARKDUPLICATES
    // //
    PICARD_MARKDUPLICATES (
    PICARD_SORTSAM.out.bam, // tuple val(meta), path(reads)
    ch_genome_fasta, // tuple val(meta2), path(fasta)
    BWA_INDEX.out.index // tuple val(meta3), path(fai)
    )

    // // //
    // // // MODULE: SAMTOOLS_INDEX
    // // //
    // SAMTOOLS_INDEX (
    // ch_genome_fasta // tuple val(meta), path(input)
    // )
    // // SAMTOOLS_INDEX.out.fai[1].view() // vorrei prendere il 2nd element ma si deve fare cosi:
    // fasta_fai = SAMTOOLS_INDEX.out.fai.subscribe { result ->
    // // Assuming result is a list or tuple, extract the second element
    // def second_argument = result[1]
    // println(second_argument)
    // }



    // //
    // // MODULE: SAMTOOLS_DICT
    // //
    SAMTOOLS_FAIDX (
    ch_genome_fasta // tuple val(meta), path(input)
    )


    // //
    // // MODULE: SAMTOOLS_DICT
    // //
    SAMTOOLS_DICT (
    ch_genome_fasta // tuple val(meta), path(input)
    )


    // transform info from mark dup into something that fits GATK4_BASERECALIBRATOR 
    picard_mark_dup_bam = PICARD_MARKDUPLICATES.out.bam
    picard_mark_dup_bai = PICARD_MARKDUPLICATES.out.bai
    picard_mark_dup_metrics = PICARD_MARKDUPLICATES.out.metrics
    
    tup_meta_bam_bai_int = (picard_mark_dup_bam.join(picard_mark_dup_bai)).join(picard_mark_dup_metrics)
    .map{ meta, bam, bai, met -> [ meta, bam, bai, [] ] } // [] = no intervals provided
    //tup_meta_bam_bai_int.view()
    //> [[id:WT_REP1, single_end:false], /home/antoinebuetti/Desktop/work/varCalling_NextFlow_nfcore/nf-core-varcalgatknfcore/work/da/08b2b9033a88d112e10107ebb488fa/WT_REP1.dup.bam, /home/antoinebuetti/Desktop/work/varCalling_NextFlow_nfcore/nf-core-varcalgatknfcore/work/da/08b2b9033a88d112e10107ebb488fa/WT_REP1.dup.bai, []]

    // //
    // // MODULE: GATK4_BASERECALIBRATOR
    // //
    GATK4_BASERECALIBRATOR (
    tup_meta_bam_bai_int, // tuple val(meta), path(input), path(input_index), path(intervals)
    params.fasta, // path  fasta
    SAMTOOLS_FAIDX.out.fai.map{ meta, f -> [f] }, // path  fai
    SAMTOOLS_DICT.out.dict.map{ meta, f -> [f] }, // path  dict 
    params.vcf, // path  known_sites 
    params.vcf_tbi // path  known_sites_tbi
    )

    tup_meta_bam_bai_tab_int = tup_meta_bam_bai_int.join(GATK4_BASERECALIBRATOR.out.table)
    .map{ meta, bam, bai, interv, tab -> [ meta, bam, bai, tab, interv ] } 
    //.view()
    // //> [[id:WT_REP1, single_end:false], /home/antoinebuetti/Desktop/work/varCalling_NextFlow_nfcore/nf-core-varcalgatknfcore/work/c6/1184c8d59299ea09ec468fa6fe252f/WT_REP1.dup.bam, /home/antoinebuetti/Desktop/work/varCalling_NextFlow_nfcore/nf-core-varcalgatknfcore/work/c6/1184c8d59299ea09ec468fa6fe252f/WT_REP1.dup.bai, /home/antoinebuetti/Desktop/work/varCalling_NextFlow_nfcore/nf-core-varcalgatknfcore/work/8a/ef7e750ec4ab147c0f6ae129b3e0e9/WT_REP1.table, []]

    // //
    // // MODULE: GATK4_APPLYBQSR
    // //
    GATK4_APPLYBQSR (
    tup_meta_bam_bai_tab_int, // tuple val(meta), path(input), path(input_index), path(bqsr_table), path(intervals)
    params.fasta, // path  fasta
    SAMTOOLS_FAIDX.out.fai.map{ meta, f -> [f] }, // path  fai 
    SAMTOOLS_DICT.out.dict.map{ meta, f -> [f] }, // path  dict 
    )

    // tup_meta_fasta = params.fasta.join(SAMTOOLS_FAIDX.out.fai).map{ f, meta -> [[meta], f] }
    // tup_meta_fasta.view()

    // //
    // // MODULE: GATK4_MUTECT2
    // //
    GATK4_MUTECT2 (
    tup_meta_bam_bai_int, // tuple val(meta), path(input), path(input_index), path(intervals)
    ch_genome_fasta, // tuple val(meta2), path(fasta)
    SAMTOOLS_FAIDX.out.fai, // tuple val(meta3), path(fai)
    SAMTOOLS_DICT.out.dict, // tuple val(meta4), path(dict)
    [], // path(germline_resource) .vcf.gz
    [], // path(germline_resource_tbi) .vcf.gz.tbi
    [], // path(panel_of_normals) .vcf.gz
    [], // path(panel_of_normals_tbi) .vcf.gz.tbi
    )

    

    // ch1.join(ch2)//.join(ch3).join(ch4)
    // // .map{ meta, vcf -> [vcf] }

    // GATK4_MUTECT2.out.vcf.concat(GATK4_MUTECT2.out.tbi, GATK4_MUTECT2.out.stats)
    // .groupTuple().map{ meta, [vcf, vcftbi, stats] -> [meta] }
    // .view()


    // // tup_meta_vcf_vcftbi_stats_oribias_segm_table_est

    // ch1 = GATK4_MUTECT2.out.vcf
    // ch2 = GATK4_MUTECT2.out.tbi
    // ch3 = GATK4_MUTECT2.out.stats
    // ch4 = GATK4_MUTECT2.out.f1r2 // this is empty

    // Channel.combine(ch1, ch2, ch3).view()

// Channel
//     .combine(ch1, ch2, ch3)
    // .map { o1,o2,o3
    //         ->
    //     // Transform combined output into a tuple
    //     tuple(
    //         o1 ?: [], 
    //         o2 ?: [], 
    //         o3 ?: [], 
    //         // o4 ?: []  
    //         // o1.collectFile().toList(),
    //         // o2.collectFile().toList(),
    //         // o3.collectFile().toList(),
    //         // o4.collectFile().toList()
    //     )
    // }
    // .set { tup_meta_vcf_vcftbi_stats_oribias_segm_table_est }
    // ch1.view()
    // ch2.view()
    // ch3.view()

// tup_meta_vcf_vcftbi_stats_oribias_segm_table_est.view()




// Define empty channels to handle cases where the process output might be empty
// def empty_output = Channel.value([])

// // Collect files from each process, defaulting to empty if not produced
// def collected1 = ch1.ifEmpty([]).map { it -> it.collect() }
// def collected2 = ch2.ifEmpty([]).map { it -> it.collect() }
// def collected3 = ch3.ifEmpty([]).map { it -> it.collect() }
// def collected4 = ch4.ifEmpty([]).map { it -> it.collect() }

// // Combine outputs from the four processes
// Channel
//     .combine(collected1, collected2, collected3, collected4)
//     .map { o1, o2, o3, o4 ->
//         // Transform combined output into a tuple
//         tuple(
//             o1 ?: [],
//             o2 ?: [],
//             o3 ?: [],
//             o4 ?: []
//         )
//     }
//     .set { combined_output }

// combined_output.view()

// ch1.ifEmpty([]).map { it -> it.collect() }.view()
// ch2.ifEmpty([]).map { it -> it.collect() }.view()
// ch3.ifEmpty([]).map { it -> it.collect() }.view()
// ch4.ifEmpty([]).map { it -> it.collect() }.view()

// combine(
// ch1.ifEmpty([]).map { it -> it.collect() },
// ch2.ifEmpty([]).map { it -> it.collect() },
// // ch3.ifEmpty([]).map { it -> it.collect() },
// // ch4.ifEmpty([]).map { it -> it.collect() }
//         ).view()




// // Ensure all output channels have a default value if empty
// output1 = output1.ifEmpty(empty_output)
// output2 = output2.ifEmpty(empty_output)
// output3 = output3.ifEmpty(empty_output)
// output4 = output4.ifEmpty(empty_output)

// // Mix all output channels
// def mixedOutput = Channel.from
//     .mix(output1.ifEmpty([]), output2.ifEmpty([]), output3.ifEmpty([]), output4.ifEmpty([]))


    ch1 = GATK4_MUTECT2.out.vcf
    ch2 = GATK4_MUTECT2.out.tbi
    ch3 = GATK4_MUTECT2.out.stats
    ch4 = GATK4_MUTECT2.out.f1r2 // this is empty

    Channel.mix(ch1, ch2, ch3).view()


    // // //
    // // // MODULE: GATK4_FILTERMUTECTCALLS
    // // //
    // GATK4_FILTERMUTECTCALLS (
    // // tuple val(meta), path(vcf), path(vcf_tbi), path(stats), path(orientationbias), path(segmentation), path(table), val(estimate)
    // ch_genome_fasta, // tuple val(meta2), path(fasta)
    // SAMTOOLS_FAIDX.out.fai, // tuple val(meta3), path(fai)
    // SAMTOOLS_DICT.out.dict, // tuple val(meta4), path(dict)
    // )

    emit:
    multiqc_report = MULTIQC.out.report.toList() // channel: /path/to/multiqc_report.html
    versions       = ch_versions                 // channel: [ path(versions.yml) ]
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    THE END
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/
